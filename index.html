<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sliding Puzzle</title>

  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      background: #f4f4f4;
    }

    #puzzle {
      position: relative;
      display: grid;
      gap: 2px;
      background: #333;
      touch-action: manipulation;
    }

    .tile {
      background-size: 100% 100%;
      background-repeat: no-repeat;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .empty {
      background: #222;
    }

    .tile {
  aspect-ratio: 1 / 1;   /* forces squares */
  width: 100%;
  height: 100%;
}

    #timer {
      margin-top: 20px;
      font-size: 20px;
    }
  </style>
</head>
<body>

<h1>Sliding Puzzle</h1>

<div id="puzzle"></div>
<div id="timer">Time: <span id="time">0.0</span>s</div>

<script>
/* -----------------------------
   CONFIG
------------------------------ */
const gridSize = 4;         // Change to 5 for 5Ã—5
const imageUrl =
  "https://images.unsplash.com/photo-1506744038136-46273834b3fb?auto=format&fit=crop&w=600&q=60";

const tileCount = gridSize * gridSize;
let tiles = [];
let emptyIndex = tileCount - 1;

let startTime = null;
let timerRunning = false;

/* -----------------------------
   TIMER
------------------------------ */
function startTimer() {
  if (!timerRunning) {
    timerRunning = true;
    startTime = performance.now();
    updateTimer();
  }
}

function updateTimer() {
  if (!timerRunning) return;
  const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
  document.getElementById("time").textContent = elapsed;
  requestAnimationFrame(updateTimer);
}

/* -----------------------------
   SETUP PUZZLE GRID
------------------------------ */
const puzzle = document.getElementById("puzzle");
puzzle.style.width = "400px";
puzzle.style.height = "400px";
puzzle.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
puzzle.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;

/* -----------------------------
   CREATE TILES
------------------------------ */
function createTiles() {
  const tileSizePercent = 100 / (gridSize - 1);

  for (let i = 0; i < tileCount; i++) {
    const tile = document.createElement("div");
    tile.classList.add("tile");
    tile.dataset.index = i;

    if (i === emptyIndex) {
      tile.classList.add("empty");
    } else {
      const x = (i % gridSize) * (100 / (gridSize - 1));
      const y = Math.floor(i / gridSize) * (100 / (gridSize - 1));

      tile.style.backgroundImage = `url("${imageUrl}")`;
      tile.style.backgroundSize = `${gridSize * 100}% ${gridSize * 100}%`;
      tile.style.backgroundPosition = `-${(i % gridSize) * (100 / (gridSize))}% -${Math.floor(i / gridSize) * (100 / (gridSize))}%`;
    }

    tile.addEventListener("click", () => tryMove(i));

    tiles.push(tile);
    puzzle.appendChild(tile);
  }
}

/* -----------------------------
   NEIGHBOR CHECK
------------------------------ */
function isNeighbor(i1, i2) {
  const r1 = Math.floor(i1 / gridSize);
  const c1 = i1 % gridSize;
  const r2 = Math.floor(i2 / gridSize);
  const c2 = i2 % gridSize;

  return (r1 === r2 && Math.abs(c1 - c2) === 1) ||
         (c1 === c2 && Math.abs(r1 - r2) === 1);
}

/* -----------------------------
   MOVE LOGIC
------------------------------ */
function tryMove(i) {
  if (!isNeighbor(i, emptyIndex)) return;
  startTimer();

  const clicked = tiles[i];
  const empty = tiles[emptyIndex];

  // Swap backgrounds
  empty.style.backgroundImage = clicked.style.backgroundImage;
  empty.style.backgroundPosition = clicked.style.backgroundPosition;
  empty.classList.remove("empty");

  clicked.style.backgroundImage = "";
  clicked.classList.add("empty");

  emptyIndex = i;
}

/* -----------------------------
   SHUFFLE
------------------------------ */
function shuffle() {
  let moves = 200;
  while (moves > 0) {
    const neighbors = [];
    for (let i = 0; i < tileCount; i++) {
      if (isNeighbor(i, emptyIndex)) neighbors.push(i);
    }
    const move = neighbors[Math.floor(Math.random() * neighbors.length)];
    tryMove(move);
    moves--;
  }
  timerRunning = false;
  document.getElementById("time").textContent = "0.0";
}

/* -----------------------------
   INIT
------------------------------ */
createTiles();
shuffle();
</script>

</body>
</html>
